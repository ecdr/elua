// RTC platform - SAM#include "platform_conf.h"#include <asf.h>#include "module_rtc.h"#ifdef BUILD_RTC#warning Be sure actually have 32khz crystal before building this module// Limit how long will wait for the 32khz crystal to be ready// FIXME: Number is arbitrary at the moment, check manuals to see how long should wait#define RTC_TIMEOUT_COUNT 5000000static u8 rtc_initialized = 0;	// Have we set up RTC?// void RTC_Handler( void )  /* Initialise the RTC subsystem: * Return 0 for success, non-zero if no RTC or failure * * TODO: If none, do the RTC stuff using the one-second-tick system timer (or rtt?) */int platform_rtc_init( void ){  u32 waitlimit;    if (rtc_initialized) return 0;  pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);  for (waitlimit = 0; RTC_TIMEOUT_COUNT; waitlimit++)    if (pmc_osc_is_ready_32kxtal())      {      rtc_set_hour_mode(RTC, 0);    // 24 hour mode      rtc_initialized = 1;      return 0;      };  // timeout - 32k crystal never got ready  // FIXME: see if there is any other cleanup to do (e.g. change sclk to a different source)  // Or, if there is no recovery, can it print an error message?  return 1;}void platform_read_rtc(uint32_t * hour, uint32_t * minute, uint32_t * second, uint32_t * year, uint32_t * month, uint32_t * day, uint32_t * week){  rtc_get_time(RTC, hour, minute, second);  rtc_get_date(RTC, year, month, day, week);}uint32_t platform_write_rtc(uint32_t hour, uint32_t minute, uint32_t second, uint32_t year, uint32_t month, uint32_t day, uint32_t week){  u32 result; 	result = rtc_set_time (RTC, hour, minute, second); 	result |= rtc_set_date (RTC, year, month, day, week);   // FIXME: result handling - does this make sense?  return result;}#endif // BUILD_RTC